{"version":3,"sources":["kuhumcst/rescope/select.cljs"],"mappings":"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","names":["var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","kuhumcst.rescope.select/element","seq56390","self__4724__auto__","cljs.core/seq","tags","cljs.core/empty?","cljs.core/vector?","cljs.core.every_pred","cljs.core.comp","cljs.core/set","cljs.core/first","kuhumcst.rescope.select/attr","attr","contains-attr?","p__56404","vec__56405","cljs.core.nth","_","m","cljs.core/set?","cljs.core/every?","cljs.core.partial","cljs.core/contains?","cljs.core/map?","cljs.core/second","kuhumcst.rescope.select/select-while","seq56413","G__56420","cljs.core/next","G__56421","self__4723__auto__","coll-pred","hiccup","preds","matches?","cljs.core.apply","cljs.core/every-pred","collect","p__56440","vec__56441","coll","node","loc","G__56444","cljs.core/not","cljs.core/reduced","cljs.core.conj","zip-iter","cljs.core/iterate","clojure.zip/next","hickory.zip/hiccup-zip","cljs.core.reduce","cljs.core.take_while","cljs.core/complement","clojure.zip/end?","kuhumcst.rescope.select/all","seq56446","G__56447","cljs.core/constantly","kuhumcst.rescope.select/one","seq56470","G__56471","p1__56469#","cljs.core/count"],"sourcesContent":["(ns kuhumcst.rescope.select\n  \"Select elements in a hiccup tree.\"\n  (:require [clojure.zip :as zip]\n            [hickory.zip :as hzip]))\n\n(defn element\n  \"Create an element selector predicate for element `tags`. Will select elements\n  present in the list of tags. Selects all elements if no tags are specified.\"\n  [& tags]\n  (if (empty? tags)\n    vector?\n    (every-pred vector? (comp (set tags) first))))\n\n(defn attr\n  \"Create an attribute selector predicate based on `attr`. Passing a set as attr\n  will test for the existence of attribute keys, while passing a map will test\n  for matching key-value pairs of attributes.\"\n  [attr]\n  (let [contains-attr? (fn [[_ m]]\n                         (cond\n                           (set? attr) (every? (partial contains? m) attr)\n                           (map? attr) (every? (set m) attr)\n                           :else (contains? m attr)))]\n    (every-pred vector? (comp map? second) contains-attr?)))\n\n(defn select-while\n  \"Select elements satisfying `preds` in a `hiccup` tree while (coll-pred coll)\n  returns logically true.\"\n  [coll-pred hiccup & preds]\n  (let [matches? (apply every-pred vector? preds)\n        collect  (fn [coll [node _ :as loc]]\n                   (cond-> coll\n                     (not (coll-pred coll)) (reduced)\n                     (matches? node) (conj node)))\n        zip-iter (iterate zip/next (hzip/hiccup-zip hiccup))]\n    (reduce collect [] (take-while (complement zip/end?) zip-iter))))\n\n(defn all\n  \"Select all elements satisfying `preds` in a `hiccup` tree. If no predicates\n  are specified, all elements in the hiccup will be returned.\"\n  [hiccup & preds]\n  (apply select-while (constantly true) hiccup preds))\n\n(defn one\n  \"Select the first element satisfying `preds` in a `hiccup` tree.\"\n  [hiccup & preds]\n  (first (apply select-while #(< (count %) 1) hiccup preds)))\n"]}
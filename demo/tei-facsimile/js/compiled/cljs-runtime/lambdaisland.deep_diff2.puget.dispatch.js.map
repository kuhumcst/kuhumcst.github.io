{"version":3,"sources":["lambdaisland/deep_diff2/puget/dispatch.cljc"],"mappings":";AAUA,AAAA;;;;;;AAAA,AAAAA,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;;AAAA,AAAAC,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAJ,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAI;;;;;AAAA,AAAA,AAAA,AAAMJ,AAKFa;AALJ,AAAA,AAMU,AAACC,AAAYD;AANvB;AAAA,AAAA,AAAA,AAAAP,AAAA;;;AAOG,AAAMS,AAAW,AAACC,AAAOC,AAAKJ;AAA9B,AACMK;AADN,AAEE,AAAM,AAACC,AAAOJ;AAAd,AACE,AAAO,AAAA,AAAA,AAAA,AAAA,AAACK,AAAQF;;AADlB;;AAGA,AAAI,AAAA,AAACG,AAAI,AAACC,AAAMP;AACd,AAACN,AAAMM;;AACP,AACGQ;AADH,AAEE,AAAA,AAAAC,AAACC;AAAD,AAAO,AAAAD,AAAAA,AAAAA,AAAGD,AAAAA;AAAGR;;;;;AAhBtB,AAAA,AAAA,AAAA,AAAMf,AAiBF0B,AAAEC,AAAIC;AAjBV,AAkBG,AAACC,AAAe,AAACC,AAAMJ,AAAEC,AAAEC;;;AAlB9B;AAAA,AAAA,AAAA,AAAArB,AAAMP;AAAN,AAAA,AAAAQ,AAAA,AAAAC,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAAI,AAAA,AAAAF,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAA,AAAA,AAAAK,AAAA;AAAA,AAAA,AAAAA,AAAAJ,AAAAG,AAAAJ;;;AAAA,AAAA,AAAA,AAAMP;;AAAN,AAoBA;;;;;AAAA,AAAM+B,AAIHC;AAJH,AAKE,AAAMC,AAAM,AAAA,AAACC;AAAb,AACE,AACGX;AADH,AAEE,AAAA,AAAAY,AAAMC,AAAQH;AAAd,AACE,AAAI,AAACI,AAAUD,AAAOb;AACpB,AAACe,AAAIF,AAAOb;;AACZ,AAAMgB,AAAE,AAACP,AAAAA,AAAAA,AAAST,AAAAA;AAAlB,AACE,AAACiB,AAAMP,AAAMQ,AAAMlB,AAAEgB;;AACrBA;;;;AAIT;;;AAAA,AAAMG,AAEHC;AAFH,AAGE,AAAYC;AAAZ,AACE,AAACnB,AAAK,AAAAoB;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAAME;AAAN,AAAAD,AAAAD,AAAA,AAAA,AAAYG;AAAZ,AACE,AAAM,AAACD,AAAAA,AAAAA,AAAMJ,AAAAA;AAAb,AACEK;;AADF;;AAEFN","names":["var_args","G__51192","lambdaisland.deep-diff2.puget.dispatch/chained-lookup","args-arr__4757__auto__","len__4736__auto__","i__4737__auto__","argseq__4758__auto__","cljs.core/IndexedSeq","js/Error","seq51181","G__51182","cljs.core/first","cljs.core/next","G__51183","self__4723__auto__","dispatchers","cljs.core/sequential?","candidates","cljs.core.remove","cljs.core/nil?","no-chain-lookup-provided-message","cljs.core/empty?","cljs.core.ex_info","cljs.core._EQ_","cljs.core/count","t","p1__51178#","cljs.core/some","a","b","more","lambdaisland.deep_diff2.puget.dispatch.chained_lookup","cljs.core.list_STAR_","lambdaisland.deep-diff2.puget.dispatch/caching-lookup","dispatch","cache","cljs.core.atom","cljs.core/deref","memory","cljs.core/contains?","cljs.core.get","v","cljs.core.swap_BANG_","cljs.core/assoc","lambdaisland.deep-diff2.puget.dispatch/predicate-lookup","types","value","p__51214","vec__51215","cljs.core.nth","pred?","handler"],"sourcesContent":["(ns lambdaisland.deep-diff2.puget.dispatch\n  \"Dispatch functions take a `Class` argument and return the looked-up value.\n  This provides similar functionality to Clojure's protocols, but operates over\n  locally-constructed logic rather than using a global dispatch table.\n\n  A simple example is a map from classes to values, which can be used directly\n  as a lookup function.\"\n  (:require [clojure.string :as str]))\n\n;; ## Logical Dispatch\n(defn chained-lookup\n  \"Builds a dispatcher which looks up a type by checking multiple dispatchers\n  in order until a matching entry is found. Takes either a single collection of\n  dispatchers or a variable list of dispatcher arguments. Ignores nil\n  dispatchers in the sequence.\"\n  ([dispatchers]\n   {:pre [(sequential? dispatchers)]}\n   (let [candidates (remove nil? dispatchers)\n         no-chain-lookup-provided-message \"chained-lookup must be provided at least one dispatch function to try.\"]\n     (when (empty? candidates)\n       (throw (ex-info no-chain-lookup-provided-message\n                       {:causes #{:no-chained-lookup-provided}})))\n     (if (= 1 (count candidates))\n       (first candidates)\n       (fn lookup\n         [t]\n         (some #(% t) candidates)))))\n  ([a b & more]\n   (chained-lookup (list* a b more))))\n\n(defn caching-lookup\n  \"Builds a dispatcher which caches values returned for each type. This improves\n  performance when the underlying dispatcher may need to perform complex\n  lookup logic to determine the dispatched value.\"\n  [dispatch]\n  (let [cache (atom {})]\n    (fn lookup\n      [t]\n      (let [memory @cache]\n        (if (contains? memory t)\n          (get memory t)\n          (let [v (dispatch t)]\n            (swap! cache assoc t v)\n            v))))))\n\n;; Space for predicate-lookup. ClojureScript support\n#?(:cljs\n   (defn predicate-lookup\n     \"Look up a handler for a value based on a map from predicate to handler\"\n     [types]\n     (fn lookup [value]\n       (some (fn [[pred? handler]]\n               (when (pred? value)\n                 handler))\n             types))))\n\n;; ## Type Dispatch (Clojure)\n#?(:clj\n   (defn symbolic-lookup\n     \"Builds a dispatcher which looks up a type by checking the underlying lookup\n  using the type's _symbolic_ name, rather than the class value itself. This is\n  useful for checking configuration that must be created in situations where the\n  classes themselves may not be loaded yet.\"\n     [dispatch]\n     (fn lookup\n       [^Class t]\n       (dispatch (symbol (.getName t))))))\n\n#?(:clj\n   (defn- lineage\n     \"Returns the ancestry of the given class, starting with the class and\n  excluding the `java.lang.Object` base class.\"\n     [cls]\n     (take-while #(and (some? %) (not= Object %))\n                 (iterate #(when (class? %) (.getSuperclass ^Class %)) cls))))\n\n#?(:clj\n   (defn- find-interfaces\n     \"Resolves all of the interfaces implemented by a class, both direct (through\n  class ancestors) and indirect (through other interfaces).\"\n     [cls]\n     (let [get-interfaces (fn [^Class c] (.getInterfaces c))\n           direct-interfaces (mapcat get-interfaces (lineage cls))]\n       (loop [queue (vec direct-interfaces)\n              interfaces #{}]\n         (if (empty? queue)\n           interfaces\n           (let [^Class iface (first queue)\n                 implemented (get-interfaces iface)]\n             (recur (into (rest queue)\n                          (remove interfaces implemented))\n                    (conj interfaces iface))))))))\n\n#?(:clj\n   (defn inheritance-lookup\n     \"Builds a dispatcher which looks up a type by looking up the type itself,\n  then attempting to look up its ancestor classes, implemented interfaces, and\n  finally `java.lang.Object`.\"\n     [dispatch]\n     (fn lookup\n       [obj]\n       (let [t (class obj)]\n         (or\n          (some dispatch (lineage t))\n          (let [candidates (remove (comp nil? first)\n                                   (map (juxt dispatch identity)\n                                        (find-interfaces t)))\n                wrong-number-of-candidates-message \"%d candidates found for interfaces on dispatch type %s: %s\"]\n            (case (count candidates)\n              0 nil\n              1 (ffirst candidates)\n              (throw (ex-info (format wrong-number-of-candidates-message\n                                      (count candidates) t (str/join \", \" (map second candidates)))))))\n          (dispatch Object))))))\n"]}
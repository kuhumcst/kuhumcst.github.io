{"version":3,"sources":["hickory/zip.cljc"],"mappings":";AAOA;;;;AAAA,AAAMA,AAGHC;AAHH,AAIE,AAACC,AAAW,AAACC,AAAWC,AACZ,AAAA,AAACC,AAAKC,AACN,AAAKC,AAAKC;AAAV,AACE,AAAA,AAACC,AAAMF,AAAc,AAAAG,AAAKF;AAAL,AAAA,AAAAE;AAAc,AAACC,AAAMC,AAAOJ;;AAA5BE;;;AACvBT;;AAUd;;;AAAA,AAAOY,AAEJN;AAFH,AAGE,AAAI,AAACO,AAAQP;AAEX,AAAI,AAACQ,AAAK,AAACC,AAAOT;AAChB,AAACD,AAAI,AAAA,AAACW,AAAOV;;AACb,AAACD,AAAI,AAAA,AAACW,AAAOV;;;AAEfA;;;AAKJ;;;;AAAA,AAAOW,AAGJX,AAAKC;AAHR,AAME,AAAI,AAACM,AAAQP;AACX,AAAI,AAACQ,AAAK,AAACC,AAAOT;AAChB,AAACY,AAAK,AAAA,AAAA,AAACF,AAAOV,AAAUC;;AACxB,AAACG,AAAMC,AAAO,AAACQ,AAAMb,AAAMC;;;AAC7BA;;;AAGJ;;;AAAA,AAAMa,AAEHpB;AAFH,AAGE,AAACC,AAAWoB,AACAT,AACAK,AACAjB","names":["hickory.zip/hickory-zip","root","clojure.zip/zipper","cljs.core/complement","cljs.core/string?","cljs.core.comp","cljs.core/seq","node","children","cljs.core.assoc","and__4115__auto__","cljs.core.apply","cljs.core/vector","hickory.zip/children","cljs.core/vector?","cljs.core/map?","cljs.core/second","cljs.core.subvec","hickory.zip/make","cljs.core.into","cljs.core/first","hickory.zip/hiccup-zip","cljs.core/sequential?"],"sourcesContent":["(ns hickory.zip\n  (:require [clojure.zip :as zip]))\n\n;;\n;; Hickory\n;;\n\n(defn hickory-zip\n  \"Returns a zipper for html dom maps (as from as-hickory),\n  given a root element.\"\n  [root]\n  (zip/zipper (complement string?)\n              (comp seq :content)\n              (fn [node children]\n                (assoc node :content (and children (apply vector children))))\n              root))\n\n;;\n;; Hiccup\n;;\n\n;; Just to make things easier, we go ahead and do the work here to\n;; make hiccup zippers work on both normalized (all items have tag,\n;; attrs map, and any children) and unnormalized hiccup forms.\n\n(defn- children\n  \"Takes a hiccup node (normalized or not) and returns its children nodes.\"\n  [node]\n  (if (vector? node)\n    ;; It's a hiccup node vector.\n    (if (map? (second node)) ;; There is an attr map in second slot.\n      (seq (subvec node 2))  ;; So skip tag and attr vec.\n      (seq (subvec node 1))) ;; Otherwise, just skip tag.\n    ;; Otherwise, must have a been a node list\n    node))\n\n;; Note, it's not made clear at all in the docs for clojure.zip, but as far as\n;; I can tell, you are given a node potentially with existing children and\n;; the sequence of children that should totally replace the existing children.\n(defn- make\n  \"Takes a hiccup node (normalized or not) and a sequence of children nodes,\n   and returns a new node that has the the children argument as its children.\"\n  [node children]\n  ;; The node might be either a vector (hiccup form) or a seq (which is like a\n  ;; node-list).\n  (if (vector? node)\n    (if (map? (second node))                 ;; Again, check for normalized vec.\n      (into (subvec node 0 2) children)      ;; Attach children after tag&attrs.\n      (apply vector (first node) children))  ;; Otherwise, attach after tag.\n    children))   ;; We were given a list for node, so just return the new list.\n\n\n(defn hiccup-zip\n  \"Returns a zipper for Hiccup forms, given a root form.\"\n  [root]\n  (zip/zipper sequential?\n              children\n              make\n              root))\n"]}
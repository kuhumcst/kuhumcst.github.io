{"version":3,"sources":["meander/util/epsilon.cljc"],"mappings":"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","names":["meander.util.epsilon/cljs-env?","env","meander.util.epsilon/parse-int","s","js/parseInt","meander.util.epsilon/swap","v","i","j","cljs.core.assoc","cljs.core.nth","meander.util.epsilon/permutations","coll","cljs.core/vec","n","cljs.core/count","a","n*","a*","cljs.core.mapcat","cljs.core.map","cljs.core.range","meander.util.epsilon/k-combinations","k","cljs.core._EQ_","cljs.core.sequence","cljs.core/vector","cljs.core.comp","cljs.core.reduce","cljs.core/comp","cljs.core.repeat","cljs.core/peek","cljs.core/conj","ptrs","cljs.core.mapv","cljs.core/nth","js/Error","meander.util.epsilon/vsplit-at","cljs.core/vector?","x__4217__auto__","y__4218__auto__","cljs.core.subvec","var_args","G__47380","meander.util.epsilon/vec-partitions","cljs.core/nat-int?","G__47389","cljs.core/List","cljs.core.map_indexed","_","p__47397","vec__47398","b","meander.util.epsilon.vec_partitions","m","G__47413","cljs.core.take_while","p__47428","vec__47429","G__47435","meander.util.epsilon/coll-partitions","G__47441","cljs.core/split-at","cljs.core/cons","p__47450","vec__47452","meander.util.epsilon.coll_partitions","cljs.core/first","cljs.core/bounded-count","G__47464","cljs.core.distinct","p__47472","vec__47473","meander.util.epsilon/str-partitions","str","G__47479","cljs.core.subs","p__47484","vec__47485","G__47490","G__47491","G__47495","meander.util.epsilon/partitions","cljs.core/coll?","cljs.core.ex_info","cljs.core/type","meander.util.epsilon/coll-zip","root","clojure.zip/zipper","cljs.core/seq","coll-new","cljs.core/seq?","cljs.core/map?","cljs.core.into","cljs.core/map-entry?","cljs.core/empty","meander.util.epsilon/coll-seq","cljs.core.remove","cljs.core/tree-seq","meander.util.epsilon/zip-next-seq","loc","clojure.zip/end?","clojure.zip/node","clojure.zip/next","cljs.core/LazySeq","G__47518","meander.util.epsilon/rank","xs","cljs.core.sort_by","cljs.core/-","cljs.core/val","cljs.core/frequencies","meander.util.epsilon/re-matches?","re","meander.util.epsilon/case-test-form","form","clojure.walk/prewalk","y","meander.util.epsilon/quoted?","x","meander.util.epsilon/knit","colls","G__47542","cljs.core.concat","cljs.core.keep","G__47547","cljs.core/next","meander.util.epsilon/expand-symbol","sym","temp__5737__auto__","cljs-ns","cljs.core/qualified-symbol?","ns-sym","cljs.core.symbol","cljs.core/namespace","ns","cljs.core.get","cljs.core/name","meander.util.epsilon/js-value?","meander.util.epsilon/make-js-value","meander.util.epsilon/val-of-js-value"],"sourcesContent":["(ns ^:no-doc meander.util.epsilon\n  (:require [clojure.walk :as walk]\n            [clojure.zip :as zip]))\n\n\n(defn cljs-env?\n  \"true if compiling ClojureScript or in a ClojureScript setting,\n  false otherwise.\"\n  [env]\n  #?(:clj (some? (:ns env))\n     :cljs true))\n\n\n(defn parse-int\n  \"Parse the string s as an integer.\"\n  [s]\n  #?(:clj (Integer/parseInt s)\n     :cljs (js/parseInt s)))\n\n\n(defn swap\n  \"Swap the elements at positions `i` and `j` in `v`.\"\n  {:private true}\n  [v i j]\n  (-> v\n      (assoc i (nth v j))\n      (assoc j (nth v i))))\n\n\n;; SEE: https://en.wikipedia.org/wiki/Heap%27s_algorithm\n(defn permutations\n  \"Return a sequence of all the ways to arrange coll.\"\n  [coll]\n  (let [v (vec coll)\n        n (count v)]\n    (loop [n n\n           a [v]]\n      (if (zero? n)\n        a\n        (let [n* (dec n)\n              a* (mapcat\n                  (fn step [v]\n                    (map\n                     (fn [i]\n                       (swap v i n*))\n                     (range n)))\n                  a)]\n          (recur n* a*))))))\n\n\n(defn k-combinations\n  \"All the ways to choose k items from coll.\"\n  [coll k]\n  (if (= k 1)\n    (sequence (map vector) coll)\n    (let [coll (vec coll)\n          n (count coll)]\n      (sequence\n       (comp\n        (reduce comp\n                (repeat (dec k)\n                        (mapcat\n                         (fn [v]\n                           (let [i (peek v)]\n                             (map conj (repeat v) (range i)))))))\n        (mapcat permutations)\n        (map\n         (fn [ptrs]\n           (mapv nth (repeat coll) ptrs))))\n       (map vector (range n))))))\n\n\n(defn vsplit-at\n  \"Like `clojure.core/split-at` but for vectors.\"\n  ([n v]\n   {:pre [(vector? v)]}\n   (let [i (min n (count v))]\n     [(subvec v 0 i) (subvec v i)])))\n\n\n(defn vec-partitions\n  \"\n  (let [coll [:a :b]\n        n 3]\n  (vec-partitions n coll))\n  ;; => ([[] [] [:a :b]]\n  ;;     [[] [:a] [:b]]\n  ;;     [[:a] [] [:b]]\n  ;;     [[] [:a :b] []]\n  ;;     [[:a] [:b] []]\n  ;;     [[:a :b] [] []])\n  \"\n  {:private true}\n  ([n v]\n   {:pre [(nat-int? n)]}\n   (case n\n     0 (list [])\n     1 (list [v])\n     2 (sequence\n        (map\n         (fn [i]\n           [(subvec v 0 i) (subvec v i)]))\n        (range (inc (count v))))\n     ;; else\n     (sequence\n      (comp (map-indexed\n             (fn [i _]\n               [(subvec v 0 i) (subvec v i)]))\n            (mapcat\n             (fn [[a b]]\n               (sequence\n                (map conj)\n                (vec-partitions (dec n) a)\n                (repeat b)))))\n      (range (inc (count v))))))\n  ([n m v]\n   {:pre [(nat-int? n) (nat-int? m)]}\n   (if (<= m (count v))\n     (case n\n       0 (list [])\n       1 (list [v])\n       2 (sequence\n          (comp (take-while\n                 (let [j (count v)]\n                   (fn [i]\n                     (<= (+ i m) j))))\n                (map\n                 (fn [i]\n                   [(subvec v 0 (+ i m)) (subvec v (+ i m))])))\n          (range (inc (count v))))\n       ;; else\n       (sequence\n        (comp (take-while\n               (let [j (count v)]\n                 (fn [i]\n                   (<= (+ i m) j))))\n              (map\n               (fn [i]\n                 [(subvec v 0 (+ i m)) (subvec v (+ i m))]))\n              (mapcat\n               (fn [[a b]]\n                 (sequence\n                  (map conj)\n                  (vec-partitions (dec n) m a)\n                  (repeat b)))))\n        (range (inc (count v)))))\n     (list []))))\n\n\n(defn coll-partitions\n  {:private true}\n  ([n coll]\n   {:pre [(nat-int? n)]}\n   (case n\n     0 (list [])\n     1 (list [coll])\n     2 (sequence\n        (map-indexed\n         (fn [i _]\n           (split-at i coll)))\n        (cons 1 coll))\n     ;; else\n     (sequence\n      (comp\n       (map-indexed\n        (fn [i _]\n          (split-at i coll)))\n       (mapcat\n        (fn [[a b]]\n          (sequence\n           (map conj)\n           (coll-partitions (dec n) a)\n           (repeat b)))))\n      ;; Adding one more element to the coll ensures we split at 0\n      ;; *and* at (count coll) without counting the collection.\n      (cons (first coll) coll))))\n  ([n m coll]\n   {:pre [(nat-int? n) (nat-int? m)]}\n   (if (<= m (bounded-count m coll))\n     (case n\n       0 (list [])\n       1 (list [coll])\n       2 (sequence\n          (comp (map-indexed\n                 (fn [i _]\n                   (split-at (+ i m) coll)))\n                (distinct))\n          (cons 1 coll))\n       ;; else\n       (sequence\n        (comp (map-indexed\n               (fn [i _]\n                 (split-at (+ i m) coll)))\n              (distinct)\n              (mapcat\n               (fn [[a b]]\n                 (sequence\n                  (map conj)\n                  (coll-partitions (dec n) m a)\n                  (repeat b)))))\n        ;; Adding one more element to the coll ensures we split at 0\n        ;; *and* at (count coll) without counting the collection.\n        (cons (first coll) coll)))\n     (list []))))\n\n\n(defn str-partitions\n  \"\n  Examples:\n\n  (let [str \\\"ab\\\"\n      n 0]\n  (str-partitions n str))\n  ;; => ([])\n\n  (let [str \\\"ab\\\"\n      n 1]\n  (partitions n coll))\n  ;; => ([\\\"ab\\\"])\n\n  (let [str \\\"ab\\\"\n      n 2]\n  (partitions n coll))\n  ;; => ([[] [\\\"ab\\\"]\n  ;;     [[\\\"a\\\"] [\\\"b\\\"]]\n  ;;     [[\\\"ab\\\"] []])\n\n  (let [str \\\"ab\\\"\n      n 3]\n  (partitions n coll))\n  ;; => ([[] [] [\\\"ab\\\"]]\n  ;;     [[] [\\\"a\\\"] [\\\"b\\\"]]\n  ;;     [[\\\"a\\\"] [] [\\\"b\\\"]]\n  ;;     [[] [\\\"ab\\\"] []]\n  ;;     [[\\\"a\\\"] [\\\"b\\\"] []]\n  ;;     [[\\\"ab\\\"] [] []])\n  \"\n  [n str]\n  {:pre [(nat-int? n)]}\n  (case n\n    0 (list [])\n    1 (list [str])\n    2 (sequence\n       (map\n        (fn [i]\n          [(subs str 0 i) (subs str i)]))\n       (range (inc (.length str))))\n    ;; else\n    (sequence\n     (comp\n      (map\n       (fn [i]\n         [(subs str 0 i) (subs str i)]))\n      (mapcat\n       (fn [[a b]]\n         (sequence\n          (map conj)\n          (str-partitions (dec n) a)\n          (repeat b)))))\n     (range (inc (.length str))))))\n\n\n(defn partitions \"\n  Examples:\n\n  (def coll [:a :b])\n\n  (partitions 0 coll))\n  ;; => ([])\n\n  (partitions 1 coll)\n  ;; => ([[:a :b]])\n\n  (partitions 2 coll)\n  ;; => '([[] [:a :b]]\n  ;;      [[:a] [:b]]\n  ;;      [[:a :b] []])\n\n  (partitions 3 coll)\n  ;; => '([[] [] [:a :b]]\n  ;;      [[] [:a] [:b]]\n  ;;      [[:a] [] [:b]]\n  ;;      [[] [:a :b] []]\n  ;;      [[:a] [:b] []]\n  ;;      [[:a :b] [] []])\n  \"\n  ([n coll]\n   (cond\n     (vector? coll)\n     (vec-partitions n coll)\n\n     (coll? coll)\n     (coll-partitions n coll)\n\n     (string? coll)\n     (str-partitions n coll)\n\n     (nil? coll)\n     ()\n\n     :else\n     (throw (ex-info \"coll must be a string? or coll?\" {:type (type coll)}))))\n  ([n m coll]\n   (cond\n     (vector? coll)\n     (vec-partitions n m coll)\n\n     (coll? coll)\n     (coll-partitions n m coll)\n\n     (string? coll)\n     (str-partitions n coll)\n\n     (nil? coll)\n     ()\n\n     :else\n     (throw (ex-info \"coll must be a string? or coll?\" {:type (type coll)})))))\n\n(defn coll-zip\n  [root]\n  (zip/zipper coll?\n              seq\n              (fn [coll coll-new]\n                (cond\n                  (seq? coll)\n                  coll-new\n\n                  (map? coll)\n                  (into {} coll-new)\n\n                  (map-entry? coll)\n                  (vec coll-new)\n\n                  :else\n                  (into (empty coll) coll-new)))\n              root))\n\n(defn coll-seq\n  \"Return a lazy sequence of all the nodes in the tree `root`\n  excluding `map-entry?`s.\"\n  [root]\n  (remove map-entry? (tree-seq coll? seq root)))\n\n(defn zip-next-seq\n  \"Given a clojure.zip zipper location loc return a lazy sequence of\n  all clojure.zip/next locations from loc. Note that `map-entry?`s\n  are skipped.\"\n  [loc]\n  (cond\n    (zip/end? loc)\n    ()\n\n    (map-entry? (zip/node loc))\n    (recur (zip/next loc))\n\n    :else\n    (lazy-seq (cons loc (zip-next-seq (zip/next loc))))))\n\n(defn rank\n  \"Returns a sorted sequence of values in xs by frequency of\n  occurence.\"\n  [xs]\n  (map first (sort-by (comp - val) (frequencies xs))))\n\n(defn re-matches?\n  \"Returns true if s matches the regex pattern re, false otherwise.\"\n  [re s]\n  #?(:clj\n     (.matches (re-matcher re s))\n     :cljs\n     (.test re s)))\n\n(defn case-test-form\n  \"Converts all `form` into a form suitable for use as a `case`\n  test. Assumes `form` is already a literal value.\"\n  [form]\n  (walk/prewalk\n   (fn [y]\n     (if (seq? y)\n       (vec y)\n       y))\n   form))\n\n\n(defn quoted?\n  \"`true` if `x` is a quoted form, e.g. `(quote _)`, and `false`\n  otherwise.\"\n  [x]\n  (and (seq? x) (= (first x) 'quote)))\n\n(defn knit\n  [colls]\n  (case (bounded-count 2 colls)\n    0 ()\n\n    1 (if (seq (first colls))\n        (first colls)\n        ())\n\n    ;; else\n    (concat\n     (sequence (comp (keep seq)\n                     (map first))\n               colls)\n     (lazy-seq (knit (keep next colls))))))\n\n(defn expand-symbol\n  [sym env]\n  #?(:clj (if-some [cljs-ns (:ns env)]\n            ;; ClojureScript compile-time\n            (if (qualified-symbol? sym)\n              (let [ns-sym (symbol (namespace sym))]\n                (if-some [ns (get (:requires cljs-ns) ns-sym)]\n                  (symbol (name ns) (name sym))\n                  sym))\n              (symbol (name (:name cljs-ns)) (name sym)))\n            ;; Clojure\n            (if (qualified-symbol? sym)\n              (let [ns-sym (symbol (namespace sym))]\n                (if-some [ns (get (ns-aliases *ns*) ns-sym)]\n                  (symbol (name (ns-name ns)) (name sym))\n                  sym))\n              (symbol (name (ns-name *ns*)) (name sym))))\n     :cljs (if-some [cljs-ns (:ns env)]\n             (if (qualified-symbol? sym)\n               (let [ns-sym (symbol (namespace sym))]\n                 (if-some [ns (get (:requires cljs-ns) ns-sym)]\n                   (symbol (name ns) (name sym))\n                   sym))\n               (symbol (name (:name cljs-ns)) (name sym)))\n             sym)))\n\n#?(:clj\n   (try\n     (let [c (Class/forName \"cljs.tagged_literals.JSValue\")]\n       (defn js-value? [x]\n         (instance? c x)))\n     (catch ClassNotFoundException _\n       (defn js-value? [x]\n         false)))\n   :cljs\n   (defn js-value? [x]\n     false))\n\n#?(:clj\n   (try\n     (let [c (Class/forName \"cljs.tagged_literals.JSValue\")\n           s 'cljs.tagged_literals.JSValue]\n       (defn make-js-value [x]\n         (eval `(new ~s ~x))))\n     (catch ClassNotFoundException _\n       (defn make-js-value [x]\n         x)))\n   :cljs\n   (defn make-js-value [x] x))\n\n(defn val-of-js-value [x]\n  (if (js-value? x) (.val x) x))\n"]}
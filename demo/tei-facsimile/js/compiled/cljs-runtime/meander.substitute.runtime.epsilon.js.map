{"version":3,"sources":["meander/substitute/runtime/epsilon.cljc"],"mappings":";;AAGA,AAAKA,AACH,AAAA,AAAA,AAACC;AAKH,AAAA,AAAMC,AAAUC;AAAhB,AAEW,AAACC,AAAKD;;AAEjB,AAEEE,AAES,AAAOC;AAAP,AACE,AAAI,AAAUA;AACZ,AAAAC,AAAA,AAAA;AAAA,AAAU,AAACC,AAAK,AAAOF,AAAG,AAACG,AAAEH;AAA7B,AAAA;;AADF","names":["meander.substitute.runtime.epsilon/FAIL","cljs.core.ex_info","meander.substitute.runtime.epsilon/iterator","coll","cljs.core/iter","meander.substitute.runtime.epsilon/iterator-seq","i","cljs.core/LazySeq","cljs.core/cons","f"],"sourcesContent":["(ns ^:no-doc meander.substitute.runtime.epsilon\n  (:refer-clojure :exclude [iterator-seq]))\n\n(def FAIL\n  (ex-info \"\" {}))\n\n(defmacro fail? [x]\n  `(identical? ~x FAIL))\n\n(defn iterator [coll]\n  #?(:clj (clojure.lang.RT/iter coll)\n     :cljs (iter coll)))\n\n(def\n  ^{:arglists '([iter])}\n  iterator-seq\n  #?(:clj clojure.core/iterator-seq\n     :cljs (fn f [i]\n             (if (.hasNext i)\n               (lazy-seq (cons (.next i) (f i)))))))\n\n"]}
{"version":3,"sources":["meander/match/runtime/epsilon.cljc"],"mappings":"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","names":["meander.match.runtime.epsilon/permutations","meander.util.epsilon/permutations","meander.match.runtime.epsilon/k-combinations","meander.util.epsilon/k-combinations","meander.match.runtime.epsilon/partitions","meander.util.epsilon/partitions","meander.match.runtime.epsilon/coll-zip","meander.util.epsilon/coll-zip","meander.match.runtime.epsilon/coll-seq","meander.util.epsilon/coll-seq","meander.match.runtime.epsilon/zip-next-seq","meander.util.epsilon/zip-next-seq","meander.match.runtime.epsilon/knit","meander.util.epsilon/knit","meander.match.runtime.epsilon/FAIL","js/meander","js/meander.match","js/meander.match.runtime","js/meander.match.runtime.epsilon","js/meander.match.runtime.epsilon.t_meander$match$runtime$epsilon47591","meander.match.runtime.epsilon/t_meander$match$runtime$epsilon47591","_47593","meta47592","this__4369__auto__","writer__4370__auto__","opt__4371__auto__","cljs.core/-write","meander.match.runtime.epsilon/->t_meander$match$runtime$epsilon47591","_","meander.match.runtime.epsilon/fail?","x","meander.match.runtime.epsilon/run-star-1","coll","rets","body-f","then-f","result","cljs.core.reduce","acc","xs","G__47616","G__47617","cljs.core/reduced","meander.match.runtime.epsilon/run-star-seq","n","cljs.core.take","cljs.core._EQ_","cljs.core/count","cljs.core.drop","cljs.core/seq","meander.match.runtime.epsilon/run-star-seq-search","cljs.core.mapcat","G__47626","G__47627","G__47628","G__47629","G__47630","meander.match.runtime.epsilon/run-plus-seq-search","m","m*n","ys","cljs.core.sequence","cljs.core.apply","cljs.core/comp","cljs.core.map","chunk","cljs.core.partition","meander.match.runtime.epsilon/run-star-vec","cljs.core.subvec","x__4217__auto__","y__4218__auto__","meander.match.runtime.epsilon/run-star-vec-search","G__47677","G__47678","G__47679","G__47680","G__47681","meander.match.runtime.epsilon/run-plus-vec-search","meander.match.runtime.epsilon/run-star-js-array","meander.match.runtime.epsilon/run-star-js-array-search","G__47724","G__47725","G__47726","G__47727","G__47728","meander.match.runtime.epsilon/run-plus-js-array-search"],"sourcesContent":["(ns ^:no-doc meander.match.runtime.epsilon\n  \"Functions used by the pattern matcher at runtime.\"\n  (:require [meander.util.epsilon :as r.util]\n            [clojure.walk :as walk]\n            [clojure.set :as set]\n            [clojure.zip :as zip]))\n\n(def permutations r.util/permutations)\n(def k-combinations r.util/k-combinations)\n(def partitions r.util/partitions)\n(def coll-zip r.util/coll-zip)\n(def coll-seq r.util/coll-seq)\n(def zip-next-seq r.util/zip-next-seq)\n(def knit r.util/knit)\n\n(def FAIL\n  \"Special value signaling a match failure. Generated code will often\n  utilize this value for control flow purposes.\"\n  #?(:clj\n     (reify\n       clojure.lang.Seqable\n       (seq [_] nil))\n\n     :cljs\n     (reify\n       ISeqable\n       (-seq [_] nil))))\n\n(defn fail?\n  \"true if the `x` is the special runtime value `FAIL`, false\n  otherwise.\"\n  [x]\n  (identical? x FAIL))\n\n(defn run-star-1\n  {:style/indent :defn}\n  [coll rets body-f then-f]\n  (let [result\n        (reduce (fn [acc xs]\n                  (let [acc (body-f acc [xs])]\n                    (if (fail? acc)\n                      (reduced FAIL)\n                      acc)))\n                rets\n                coll)]\n    (if (fail? result)\n      FAIL\n      (then-f result))))\n\n\n(defn run-star-seq\n  {:style/indent :defn}\n  [coll rets n body-f then-f]\n  (loop [coll coll\n         rets rets]\n    (let [xs (take n coll)]\n      (if (= (count xs) n)\n        (let [rets (body-f rets xs)]\n          (if (fail? rets)\n            FAIL\n            (recur (drop n coll) rets)))\n        (if (seq coll)\n          FAIL\n          (then-f rets))))))\n\n(defn run-star-seq-search\n  {:style/indent :defn}\n  [coll rets n body-f then-f]\n  (let [xs (take n coll)]\n    (if (= (count xs) n)\n      (mapcat\n       (fn [rets]\n         (if (fail? rets)\n           nil\n           (run-star-seq-search (drop n coll) rets n body-f then-f)))\n       (body-f rets xs))\n      (if (seq coll)\n        nil\n        (then-f rets)))))\n\n(defn run-plus-seq-search\n  {:style/indent :defn\n   :arglists '([coll rets cat-length min-reps body-f then-f])}\n  [coll rets n m body-f then-f]\n  (let [m*n (* m n)\n        xs (take m*n coll)]\n    (if (= (count xs) m*n)\n      (let [ys (drop m*n coll)]\n        (mapcat\n         (fn [rets]\n           (if (fail? rets)\n             nil\n             (run-star-seq-search ys rets n body-f then-f)))\n         (sequence\n          (apply comp\n                 (map (fn [chunk]\n                        (mapcat (fn [rets]\n                                  (if (fail? rets)\n                                    nil\n                                    (body-f rets chunk)))))\n                      (partition n xs)))\n          [rets])))\n      (if (seq coll)\n        nil\n        (then-f rets)))))\n\n(defn run-star-vec\n  {:style/indent :defn}\n  [coll rets n body-f then-f]\n  (loop [coll coll\n         rets rets]\n    (let [xs (subvec coll 0 (min n (count coll)))]\n      (if (= (count xs) n)\n        (let [rets (body-f rets xs)]\n          (if (fail? rets)\n            FAIL\n            (recur (subvec coll (min n (count coll))) rets)))\n        (if (seq coll)\n          FAIL\n          (then-f rets))))))\n\n(defn run-star-vec-search\n  {:style/indent :defn}\n  [coll rets n body-f then-f]\n  (let [xs (subvec coll 0 (min n (count coll)))]\n    (if (= (count xs) n)\n      (mapcat\n       (fn [rets]\n         (if (fail? rets)\n           nil\n           (run-star-vec-search (subvec coll n) rets n body-f then-f)))\n       (body-f rets xs))\n      (if (seq coll)\n        nil\n        (then-f rets)))))\n\n(defn run-plus-vec-search\n  {:style/indent :defn\n   :arglists '([coll rets cat-length min-reps body-f then-f])}\n  [coll rets n m body-f then-f]\n  (let [m*n (* m n)\n        xs (subvec coll 0 (min m*n (count coll)))]\n    (if (= (count xs) m*n)\n      (let [ys (subvec coll m*n)]\n        (mapcat\n         (fn [rets]\n           (if (fail? rets)\n             nil\n             (run-star-vec-search ys rets n body-f then-f)))\n         (sequence\n          (apply comp\n                 (map (fn [chunk]\n                        (mapcat (fn [rets]\n                                  (if (fail? rets)\n                                    nil\n                                    (body-f rets chunk)))))\n                      (partition n xs)))\n          [rets])))\n      (if (seq coll)\n        nil\n        (then-f rets)))))\n\n(defn run-star-js-array\n  {:style/indent :defn}\n  [coll rets n body-f then-f]\n  (loop [coll coll\n         rets rets]\n    (let [xs (.slice coll 0 (min (.-length coll) n))]\n      (if (= (count xs) n)\n        (let [rets (body-f rets xs)]\n          (if (fail? rets)\n            FAIL\n            (recur (.slice coll n) rets)))\n        (if (seq coll)\n          FAIL\n          (then-f rets))))))\n\n(defn run-star-js-array-search\n  {:style/indent :defn}\n  [coll rets n body-f then-f]\n  (let [xs (.slice coll 0 (min n (count coll)))]\n    (if (= (count xs) n)\n      (mapcat\n       (fn [rets]\n         (if (fail? rets)\n           nil\n           (run-star-js-array-search (.slice coll n) rets n body-f then-f)))\n       (body-f rets xs))\n      (if (seq coll)\n        nil\n        (then-f rets)))))\n\n(defn run-plus-js-array-search\n  {:style/indent :defn}\n  [coll rets n m body-f then-f]\n  (let [m*n (* m n)\n        xs (.slice coll 0 (min m*n (count coll)))]\n    (if (= (count xs) m*n)\n      (let [ys (.slice coll m*n)]\n        (mapcat\n         (fn [rets]\n           (if (fail? rets)\n             nil\n             (run-star-js-array-search ys rets n body-f then-f)))\n         (sequence\n          (apply comp\n                 (map (fn [chunk]\n                        (mapcat (fn [rets]\n                                  (if (fail? rets)\n                                    nil\n                                    (body-f rets chunk)))))\n                      (partition n xs)))\n          [rets])))\n      (if (seq coll)\n        nil\n        (then-f rets)))))\n"]}
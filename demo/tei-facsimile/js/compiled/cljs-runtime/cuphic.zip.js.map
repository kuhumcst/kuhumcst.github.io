{"version":3,"sources":["cuphic/zip.cljc"],"mappings":";AAGA;;;AAAA,AAAMA,AAEHC;AAFH,AAGE,AAACC,AAAW,AAACC,AAAQC,AACA,AAACC,AAAWC,AAAK,AAACC,AAAWC,AACtCC,AACA,AAAKC,AAAKC;AAAV,AACE,AAAI,AAACP,AAAQM;AACX,AAACE,AAAU,AAAA,AAACC,AAAQF,AAAU,AAACG,AAAKJ;;AACpC,AAACE,AAAU,AAAA,AAACC,AAAQF,AAAU,AAACG,AAAKJ;;AACxCT;;AAGd;;;AAAA,AAAAc,AAAMG;;AAAN,AAAA,AAAAF,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAEIN;AAFJ,AAAAO,AAAAD,AAAA,AAAA,AAESG;AAFTH,AAEeI;AAFf,AAGE,AACE,AAACC,AAASD;AAAKA;;AADjB,AAEE,AAACE,AAAUF;AAAK,AAACE,AAAUF;;AAF7B,AAGE,AAACG,AAAOH;AAAK,AAAO,AAACG,AAAOH;;;;AAH9B,AAIQ,AAAA,AAAA,AAACI,AAAMJ;;;;;;;;AAEjB;;;AAAA,AAAMK,AAEHL,AAAIM;AAFP,AAGE,AAACC,AAAW,AAACC,AAAOC,AAAgBT,AAAIM","names":["cuphic.zip/vector-map-zip","root","clojure.zip/zipper","cljs.core.some_fn","cljs.core/vector?","cljs.core.every_pred","cljs.core/map?","cljs.core/complement","cljs.core/record?","cljs.core/seq","node","children","cljs.core/with-meta","cljs.core.into","cljs.core/meta","p__51603","vec__51604","cljs.core.nth","cuphic.zip/skip-subtree","_","loc","clojure.zip/end?","clojure.zip/right","clojure.zip/up","cljs.core.assoc","cuphic.zip/multi-replace","nodes","clojure.zip/remove","cljs.core.reduce","clojure.zip/insert-left"],"sourcesContent":["(ns cuphic.zip\n  (:require [clojure.zip :as zip]))\n\n(defn vector-map-zip\n  \"Also zips maps in addition to zipping vectors. Intentionally skips records.\"\n  [root]\n  (zip/zipper (some-fn vector?                              ; branch?\n                       (every-pred map? (complement record?)))\n              seq                                           ; children\n              (fn [node children]                           ; make-node\n                (if (vector? node)\n                  (with-meta (into [] children) (meta node))\n                  (with-meta (into {} children) (meta node))))\n              root))\n\n;; https://groups.google.com/d/msg/clojure/FIJ5Pe-3PFM/JpYDQ2ejBgAJ\n(defn skip-subtree\n  \"Fast-forward a zipper to skip the subtree at `loc`.\"\n  [[node _ :as loc]]\n  (cond\n    (zip/end? loc) loc\n    (zip/right loc) (zip/right loc)\n    (zip/up loc) (recur (zip/up loc))\n    :else (assoc loc 1 :end)))\n\n(defn multi-replace\n  \"Replace `loc` with `nodes`.\"\n  [loc nodes]\n  (zip/remove (reduce zip/insert-left loc nodes)))\n"]}
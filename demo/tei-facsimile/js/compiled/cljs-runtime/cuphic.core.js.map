{"version":3,"sources":["cuphic/core.cljc"],"mappings":"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","names":["cuphic.core/hicv","v","cljs.core/map?","cljs.core/second","cljs.core.into","cljs.core/first","cljs.core/rest","cuphic.core/->nodes","cljs.core.subvec","cuphic.core/attr-bindings","cattr","hattr","diffs","lambdaisland.deep-diff2/diff","loc","cuphic.zip/vector-map-zip","ret","clojure.zip/end?","map__52637","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","+","-","node","clojure.zip/node","pred__52639","expr__52640","cljs.core/instance?","lambdaisland.deep-diff2.diff-impl/Deletion","lambdaisland.deep-diff2.diff-impl/Insertion","cljs.core/Keyword","clojure.zip/up","clojure.zip/next","lambdaisland.deep-diff2.diff-impl/Mismatch","cljs.core/Symbol","cljs.spec.alpha.valid_QMARK_","cljs.core.assoc","p__52645","p__52646","vec__52647","cljs.core.nth","vec__52650","cuphic.core/tag+attr-bindings","ctag","htag","cljs.core._EQ_","cljs.core.merge","cuphic.core/fixed-bindings","ccoll","hcoll","cljs.core/count","G__52659","vec__52661","seq__52662","cljs.core/seq","first__52663","cljs.core/next","G__52660","vec__52664","seq__52665","first__52666","vec__52673","seq__52674","first__52675","vec__52676","seq__52677","first__52678","cnode","hnode","and__4115__auto__","temp__5735__auto__","delta","cuphic.core/bindings-delta","cljs.core/empty?","cuphic.core/section-search","cnodes","hnodes","begin","section-size","end","i","section-end","candidate","temp__5733__auto__","cljs.core/with-meta","cuphic.core/quantifier?","cljs.core.partial","cljs.spec.alpha/valid?","cuphic.core/direct-bindings","pattern","nodes","cljs.core.reduce","p__52680","vec__52681","kvs","k","kv","cljs.core.conj","cljs.core/vector?","cljs.core/conj","cljs.core/reduced","cljs.core.map","cljs.core/vector","cuphic.core/not-fragment?","x","cuphic.core/capture-pattern","parts","cljs.core.partition_by","quantifiers","cljs.core.filter","cljs.core.comp","quantifier-count","min-count","cljs.core/ffirst","cljs.core/last","cuphic.core/->patterns","cljs.core/symbol?","cuphic.core/min-capture","capture-patterns","cljs.core/+","cljs.core/meta","cuphic.core/pattern-bindings","G__52690","vec__52691","seq__52692","first__52693","vec__52694","vec__52725","seq__52726","first__52727","vec__52728","next-pattern","patterns","map__52735","quantifier","nodes-until","hit","or__4126__auto__","min-nodes?","G__52739","js/Error","bound","unbound","ret*","vec__52741","vec__52744","after","split","qnodes","anodes","cljs.core.concat","cljs.core/merge","vec__52748","vec__52751","before","bnodes","vec__52754","vec__52757","split-1","split-2","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","cuphic.core/fragment-bindings","p__52763","map__52764","seq52760","G__52761","G__52762","self__4723__auto__","fragment","limit","opts","vec__52766","vec__52769","seq__52770","first__52771","!quantifier","cljs.core/complement","cljs.core/split-with","nodes-size","min-size","search","cljs.core/not","before-search","after-search","recur-search","between-begin","between-end","between","section","x__4214__auto__","y__4215__auto__","before-section","cv","hv","tag+attr-delta","vec__52777","vec__52780","seq__52781","first__52782","bpatterns","cljs.core/not-empty","apatterns","fnodes","fragment-count","before-count","after-count","max-count","<>","cuphic.core.fragment_bindings","bdelta","adelta","qdelta","cuphic.core/bindings","cuphic","hiccup","cloc","hickory.zip/hiccup-zip","hloc","cljs.core.dissoc","vec__52786","cloc*","hloc*","cuphic.zip/skip-subtree","cuphic.core/matches","p__52796","vec__52797","cuphic.core/fragment-replace","fragment-bindings","bindings->section","symbol->value","cljs.core.mapcat","replacements","cuphic.zip/multi-replace","cuphic.core/apply-bindings","G__52803","vec__52804","vec__52807","clojure.zip/root","replacement","clojure.zip/replace","cljs.core/contains?","cuphic.core/transform","from","to","cljs.core/fn?","cuphic.core/transformer","p__52811","map__52812","seq52810","self__4724__auto__","p__52815","map__52816","cuphic.core/apply-stage","wrapper","transformers","default","cljs.core/identity","stage","G__52818","new-node","p1__52814#","cljs.core.remove","cljs.core/nil?","cuphic.core/rewrite","stages","G__52822","vec__52823","vec__52826","cljs.core.not_EQ_"],"sourcesContent":["(ns cuphic.core\n  \"Data transformations for hiccup.\"\n  (:require [clojure.spec.alpha :as s]\n            [clojure.zip :as zip]\n            [hickory.zip :as hzip]\n            [lambdaisland.deep-diff2 :as dd]\n            #?(:cljs [lambdaisland.deep-diff2.diff-impl :refer [Mismatch\n                                                                Deletion\n                                                                Insertion]])\n            [cuphic.spec :as cs]\n            [cuphic.zip :as czip])\n  #?(:clj (:import [lambdaisland.deep_diff2.diff_impl Mismatch\n                                                      Deletion\n                                                      Insertion])))\n\n;; Some of the lower-leel binding fns require recursive calls to the parent fns.\n(declare bindings-delta)\n\n(defn- hicv\n  \"Helper function for normalised destructuring of a hiccup-vector `v`.\"\n  [v]\n  (if (map? (second v))\n    v\n    (into [(first v) {}] (rest v))))\n\n(defn- ->nodes\n  [v]\n  (if (map? (second v))\n    (subvec v 2)\n    (subvec v 1)))\n\n;; TODO: replace brittle deep-diff2, sometimes different diffs in clj vs. cljs\n(defn- attr-bindings\n  \"Get the symbol->value mapping found when comparing `cattr` to `hattr`.\n  Returns nil if the two attrs don't match.\"\n  [cattr hattr]\n  (let [diffs (dd/diff cattr hattr)]\n    (loop [loc (czip/vector-map-zip diffs)\n           ret {}]\n      (if (zip/end? loc)\n        ret\n        (let [{:keys [+ -] :as node} (zip/node loc)]\n          (condp instance? node\n            Deletion\n            nil\n\n            ;; Insertions are problematic unless they are HTML attributes.\n            Insertion\n            (when (and (keyword? +)\n                       ;; Check if a keyword Insertion is inside a map.\n                       (map? (zip/node (zip/up (zip/up loc)))))\n              (recur (zip/next loc) ret))\n\n            ;; Mismatches can indicate matching logic variables.\n            Mismatch\n            (when (symbol? -)\n              (if (s/valid? ::cs/? -)\n                (recur (zip/next loc) (assoc ret - +))\n                (recur (zip/next loc) ret)))\n\n            (recur (zip/next loc) ret)))))))\n\n(defn- tag+attr-bindings\n  \"Get the symbol->value mapping found when comparing only tags and attrs of a\n  normalised Cuphic vector `cv` and a normalised Hiccup vector `hv`.\n  Returns nil if the two vectors don't match.\"\n  [[ctag cattr] [htag hattr]]\n  (cond\n    ;; If the tags match, we can rely on checking attr bindings.\n    (= ctag htag)\n    (attr-bindings cattr hattr)\n\n    ;; Otherwise, the Cuphic tag can only be a single-value placeholder,\n    ;; keeping in mind that quantifiers are dealt with elsewhere.\n    (s/valid? ::cs/? ctag)\n    (merge\n      (when (s/valid? ::cs/? ctag)\n        {ctag htag})\n      (attr-bindings cattr hattr))))\n\n(defn- fixed-bindings\n  \"Get the symbol->value mapping found comparing two sequential collections.\n  This function is used to scoop up bindings that would otherwise be skipped\n  if a quantifier is present.\n  Returns nil if the two vectors don't match.\"\n  [ccoll hcoll]\n  (when (= (count ccoll) (count hcoll))                     ; performance optm.\n    (loop [[cnode & ccoll] ccoll\n           [hnode & hcoll] hcoll\n           ret {}]\n      (if (and cnode hnode)\n        (when-let [delta (bindings-delta cnode hnode)]\n          (recur ccoll hcoll (merge ret delta)))\n        (when (and (empty? ccoll) (empty? hcoll))\n          ret)))))\n\n(defn- section-search\n  \"Find the bindings of the first occurrence of fixed-length sequence `cnodes`\n  in `hnodes` starting the search at the `begin` index. As an aid to the caller,\n  the indices of the matching subsection are attached as metadata.\"\n  [cnodes hnodes begin]\n  (when (not (empty? cnodes))\n    (let [section-size (count cnodes)\n          end          (- (count hnodes) section-size)]\n      (loop [i begin]\n        (when (<= i end)\n          (let [section-end (+ i section-size)\n                candidate   (subvec hnodes i section-end)]\n            (if-let [delta (fixed-bindings cnodes candidate)]\n              (with-meta delta {:begin i\n                                :end   section-end})\n              (recur (inc i)))))))))\n\n(def quantifier?\n  (partial s/valid? ::cs/quantifier))\n\n(defn- direct-bindings\n  \"Return 1:1 bindings between `pattern` and `nodes` as kvs.\"\n  [pattern nodes]\n  (when (= (count pattern) (count nodes))\n    (reduce (fn [kvs [k v :as kv]]\n              (cond\n                (= k v) kvs\n                (symbol? k) (conj kvs kv)\n                (vector? v) (apply conj kvs (bindings-delta k v))\n                :else (reduced nil)))\n            []\n            (map vector pattern nodes))))\n\n(defn- not-fragment?\n  [x]\n  (not (s/valid? ::cs/fragment x)))\n\n(defn capture-pattern\n  \"Create a capture pattern from a sequence of `cnodes`. Returns the input data\n  structure with relevant metadata attached, or nil if invalid.\"\n  [cnodes]\n  (let [parts            (partition-by quantifier? cnodes)\n        quantifiers      (filter (comp quantifier? first) parts)\n        quantifier-count (count quantifiers)\n        min-count        (fn []\n                           (if (s/valid? ::cs/+ (ffirst quantifiers))\n                             (count cnodes)\n                             (dec (count cnodes))))]\n    (cond\n      (> quantifier-count 1)\n      nil\n\n      (= quantifier-count 0)\n      (with-meta cnodes {:min-count (count cnodes)})\n\n      (quantifier? (first cnodes))\n      (with-meta cnodes {:quantifier :prefix\n                         :parts      parts\n                         :min-count  (min-count)})\n\n      (quantifier? (last cnodes))\n      (with-meta cnodes {:quantifier :affix\n                         :parts      parts\n                         :min-count  (min-count)})\n\n      :else\n      (with-meta cnodes {:quantifier :infix\n                         :parts      parts\n                         :min-count  (min-count)}))))\n\n(defn ->patterns\n  \"Partition a list of `cnodes` into a list of capture patterns.\"\n  [cnodes]\n  (->> (partition-by symbol? cnodes)\n       (map capture-pattern)))\n\n(defn- min-capture\n  \"Return the aggregate min-count of a list of `capture-patterns`.\"\n  [capture-patterns]\n  (reduce + (map (comp :min-count meta) capture-patterns)))\n\n(defn- pattern-bindings\n  \"Given a list of cnodes partitioned into `capture-patterns`, return the\n  bindings found in `hnodes`.\"\n  [capture-patterns hnodes]\n  (loop [ret    {}\n         hnodes hnodes\n         [pattern & [next-pattern :as patterns]] capture-patterns]\n    (let [{:keys [quantifier parts min-count]} (meta pattern)\n          nodes-until (fn [cnodes hnodes begin]\n                        (let [hit (section-search cnodes hnodes begin)]\n                          (subvec hnodes 0 (or (:begin (meta hit))\n                                               (count hnodes)))))\n          min-nodes?  (fn [quantifier nodes]\n                        (not (and (= 0 (count nodes))\n                                  (s/valid? ::cs/+ quantifier))))]\n      (if pattern\n        (when (<= min-count (count hnodes))\n          (case quantifier\n            ;; With no quantifier, we simply capture the direct bindings.\n            nil (let [bound   (subvec hnodes 0 min-count)\n                      unbound (subvec hnodes min-count)\n                      ret*    (into ret (direct-bindings pattern bound))]\n                  (recur ret* unbound patterns))\n\n            :prefix (let [[[quantifier] after] parts\n                          bound   (nodes-until next-pattern hnodes min-count)\n                          unbound (subvec hnodes (count bound))\n                          split   (- (count bound) (count after))\n                          qnodes  (subvec bound 0 split)\n                          anodes  (subvec bound split)\n                          kvs     (concat (direct-bindings after anodes)\n                                          {quantifier qnodes})]\n                      (when (min-nodes? quantifier qnodes)\n                        (recur (apply merge ret kvs) unbound patterns)))\n\n            :affix (let [[before [quantifier]] parts\n                         bound   (nodes-until next-pattern hnodes min-count)\n                         unbound (subvec hnodes (count bound))\n                         split   (count before)\n                         bnodes  (subvec bound 0 split)\n                         qnodes  (subvec bound split)\n                         kvs     (concat (direct-bindings before bnodes)\n                                         {quantifier qnodes})]\n                     (when (min-nodes? quantifier qnodes)\n                       (recur (apply merge ret kvs) unbound patterns)))\n\n            :infix (let [[before [quantifier] after] parts\n                         bound   (nodes-until next-pattern hnodes min-count)\n                         unbound (subvec hnodes (count bound))\n                         split-1 (count before)\n                         split-2 (- (count bound) (count after))\n                         bnodes  (subvec bound 0 split-1)\n                         anodes  (subvec bound split-2)\n                         qnodes  (subvec bound split-1 split-2)\n                         kvs     (concat (direct-bindings before bnodes)\n                                         (direct-bindings after anodes)\n                                         {quantifier qnodes})]\n                     (when (min-nodes? quantifier qnodes)\n                       (recur (apply merge ret kvs) unbound patterns)))))\n        ret))))\n\n;; TODO: tests\n;; TODO: :source\n(defn- fragment-bindings\n  \"Given a `fragment` Cuphic vector and a sequence of `nodes`, return a sequence\n  of bindings for matching sections.\"\n  [fragment nodes & {:keys [limit begin end] :as opts}]\n  (let [!quantifier (complement (partial s/valid? ::cs/quantifier))\n        ccoll       (if (map? (second fragment))\n                      (subvec fragment 2)\n                      (subvec fragment 1))\n        [before [quantifier & after]] (split-with !quantifier ccoll)\n        nodes-size  (count nodes)\n        min-size    (+ (count before)\n                       (count after)\n                       (if (s/valid? ::cs/+ quantifier) 1 0))]\n    (when (>= (count nodes) min-size)                       ; For performance\n      (loop [i      (or begin 0)\n             search {}\n             ret    []]\n        (cond\n          ;; Optional early return when a set end has been reached.\n          (> i end)\n          ret\n\n          ;; Optional early return when a result limit has been set.\n          (= (count ret) limit)\n          ret\n\n          ;; Return result vector when the nodes are exhausted.\n          (and (>= i nodes-size)\n               (empty? search))\n          ret\n\n          ;; Search for the `before` section when applicable.\n          ;; Returns the result vector if the search is inconclusive.\n          (and (not (:before search))\n               (seq before))\n          (if-let [before-search (section-search before nodes i)]\n            (recur (:end (meta before-search))\n                   (assoc search :before before-search)\n                   ret)\n            ret)\n\n          ;; Search for the `after` section when applicable.\n          ;; Returns the result vector if the search is inconclusive.\n          (and (not (:after search))\n               (seq after))\n          (if-let [after-search (section-search after nodes i)]\n            (recur (:end (meta after-search))\n                   (assoc search :after after-search)\n                   ret)\n            ret)\n\n          ;; Search for a recurrence of the `before` section to avoid greedy\n          ;; incidental matching of any upcoming fragments.\n          (and (not (:recur search))\n               (seq before)\n               (not (seq after)))\n          (let [recur-search (section-search before nodes i)]\n            (recur (or (:begin (meta recur-search))\n                       i)\n                   (assoc search :recur (or recur-search {}))\n                   ret))\n\n          ;; Capture nodes from `before` to `after` sections when applicable.\n          ;; If there is no `after` section, the quantifier either:\n          ;;   1) Captures until the next recurrence of the `begin` section.\n          ;;   2) Captures all of the remaining nodes.\n          quantifier\n          (let [between-begin (or (:end (meta (:before search)))\n                                  (:end (meta (last ret)))\n                                  begin)\n                between-end   (or (:begin (meta (:after search)))\n                                  (:begin (meta (:recur search)))\n                                  (count nodes))\n                between       (if (< between-begin between-end)\n                                (subvec nodes between-begin between-end)\n                                [])\n                ret*          (when (not (and (empty? between)\n                                              (s/valid? ::cs/+ quantifier)))\n                                (let [section {:begin (- between-begin\n                                                         (count before))\n                                               :end   (+ between-end\n                                                         (count after))}]\n                                  (conj ret (with-meta\n                                              (merge {quantifier between}\n                                                     (:before search)\n                                                     (:after search))\n                                              section))))]\n            (recur (max i between-end) {} (or ret* ret)))\n\n          ;; If there is NO quantifier, i.e. the entire fragment is `before`,\n          ;; we add the bindings to the result vector and increment the index.\n          (:before search)\n          (let [before-section (meta (:before search))\n                section        {:begin (:begin before-section)\n                                :end   (+ (:begin before-section)\n                                          (count before))}\n                ret*           (conj ret (with-meta (merge (:before search)\n                                                           (:after search))\n                                                    section))]\n            (recur (:end before-section) {} ret*))\n\n          ;; An unsuccessful search will return the empty list of results.\n          :else ret)))))\n\n(defn- bindings-delta\n  \"Get a delta of the local bindings as a map by comparing `cnode` to `hnode`.\n  Will return nil if the two nodes do not match.\"\n  [cnode hnode]\n  (cond\n    ;; Nothing to bind. Skip to next node.\n    (= cnode hnode)\n    {}\n\n    ;; Branches (= Hiccup vectors) can be captured here.\n    (and (vector? cnode)\n         (vector? hnode))\n    (let [cv     (hicv cnode)\n          hv     (hicv hnode)\n          cnodes (subvec cv 2)\n          hnodes (subvec hv 2)]\n      (when-let [tag+attr-delta (tag+attr-bindings (subvec cv 0 2)\n                                                   (subvec hv 0 2))]\n        ;; Fragments are bounded by segments on either side.\n        (let [[before [fragment & after]] (split-with not-fragment? cnodes)]\n          (if fragment\n            (let [bpatterns      (not-empty (->patterns before))\n                  apatterns      (not-empty (->patterns after))\n                  fnodes         (->nodes fragment)\n                  fragment-count (min-capture (->patterns fnodes))\n                  before-count   (min-capture bpatterns)\n                  after-count    (min-capture apatterns)\n                  max-count      (count hnodes)]\n              ;; As a performance optimisation, only proceed if hnodes fits the\n              ;; min-length requirements.\n              (when (<= (+ before-count after-count fragment-count)\n                        max-count)\n                ;; Fragment search is greedy within the bounded context.\n                (let [<> (fragment-bindings fragment hnodes\n                                            :begin before-count\n                                            :end (- max-count after-count))]\n                  (when (not-empty <>)\n                    (let [split-1 (:begin (meta (first <>)))\n                          split-2 (:end (meta (last <>)))\n                          bnodes  (subvec hnodes 0 split-1)\n                          anodes  (subvec hnodes split-2)]\n                      (when-let [bdelta (if bpatterns\n                                          (pattern-bindings bpatterns bnodes)\n                                          {})]\n                        (when-let [adelta (if apatterns\n                                            (pattern-bindings apatterns anodes)\n                                            {})]\n                          (let [qdelta {'<> (with-meta <>\n                                                       {:begin (+ 2 split-1)\n                                                        :end   (+ 2 split-2)})}]\n                            (with-meta (merge tag+attr-delta\n                                              bdelta\n                                              adelta\n                                              qdelta)\n                                       {:skip [cv hv]})))))))))\n\n            (when-let [delta (pattern-bindings (->patterns cnodes) hnodes)]\n              (with-meta (merge tag+attr-delta delta)\n                         {:skip [cv hv]}))))))\n\n    ;; Leafs (= content values) can be captured as bindings here.\n    (s/valid? ::cs/? cnode)\n    {cnode hnode}))\n\n(defn bindings\n  \"Get the symbol->value mapping found when comparing `cuphic` to `hiccup`.\n  Returns nil if the hiccup does not match the cuphic.\n\n  The two data structures are zipped through in parallel while their bindings\n  are collected incrementally.\"\n  [cuphic hiccup]\n  (assert (s/valid? ::cs/cuphic cuphic))                    ; elide in prod\n  (loop [cloc (hzip/hiccup-zip cuphic)\n         hloc (hzip/hiccup-zip hiccup)\n         ret  {}]\n    (if (zip/end? hloc)\n      (with-meta (dissoc ret '? '* '+) {:source hiccup})\n      (when-let [delta (bindings-delta (zip/node cloc) (zip/node hloc))]\n        ;; Subtrees should be skipped in two cases:\n        ;;   1) If the cuphic is a fragment, e.g. [:<> ...].\n        ;;   2) If the cuphic contains a quantifier, e.g. + or *.\n        ;; TODO: analyse delta rather than metadata?\n        ;; Currently, metadata notifies the `bindings` function of the need to\n        ;; skip subtrees, although this could also be accomplished by looking at\n        ;; the delta itself.\n        (let [[cloc* hloc*] (if (:skip (meta delta))\n                              [(czip/skip-subtree cloc)\n                               (czip/skip-subtree hloc)]\n                              [cloc hloc])]\n          (recur (zip/next cloc*) (zip/next hloc*) (merge ret delta)))))))\n\n(defn matches\n  \"Returns the match, if any, of `hiccup` to `cuphic`.\"\n  [cuphic hiccup]\n  (when (bindings cuphic hiccup)\n    hiccup))\n\n(defn- fragment-replace\n  \"Given a `loc` and a sequence of `fragment-bindings`, replace the loc with\n  multiple fragments with individual bindings applied.\"\n  [[node :as loc] fragment-bindings]\n  (let [parts             (subvec (hicv node) 2)\n        bindings->section (fn [symbol->value]\n                            (mapcat (fn [x]\n                                      (if (s/valid? ::cs/quantifier x)\n                                        (symbol->value x)\n                                        [(symbol->value x x)])) parts))\n        replacements      (mapcat bindings->section fragment-bindings)]\n    (czip/multi-replace loc replacements)))\n\n(defn apply-bindings\n  \"Apply `symbol->value` bindings to a piece of `cuphic`.\"\n  [symbol->value cuphic]\n  (loop [[node :as loc] (czip/vector-map-zip cuphic)]\n    (if (zip/end? loc)\n      (zip/root loc)\n      (let [replacement (symbol->value node)]\n        (recur (zip/next (cond\n                           replacement\n                           (if (s/valid? ::cs/quantifier node)\n                             (czip/multi-replace loc replacement)\n                             (zip/replace loc replacement))\n\n                           (and (s/valid? ::cs/fragment node)\n                                (contains? symbol->value '<>))\n                           (fragment-replace loc (get symbol->value '<>))\n\n                           :else loc)))))))\n\n(defn transform\n  \"Transform hiccup using cuphic from/to templates.\n\n  Substitutes symbols in `to` with bound values from `hiccup` based on symbols\n  in `from`. The cuphic templates can also be replaced with functions that\n  either produce or consume a symbol->value map. \"\n  [from to hiccup]\n  (when-let [symbol->value (if (fn? from)\n                             (from hiccup)\n                             (bindings from hiccup))]\n    (if (fn? to)\n      (to symbol->value)\n      (apply-bindings symbol->value to))))\n\n(defn transformer\n  \"Make a transform fn to transform hiccup using cuphic from/to templates.\"\n  [& {:keys [from to]}]\n  (partial transform from to))\n\n(defn- apply-stage\n  \"Apply a `stage` of transformations to a Hiccup `node`.\"\n  [node {:keys [wrapper transformers default]\n         :or   {default identity}\n         :as   stage}]\n  (default (if-let [new-node (->> (map #(% node) transformers)\n                                  (remove nil?)\n                                  (first))]\n             (if wrapper\n               (wrapper node new-node)\n               new-node)\n             node)))\n\n(defn rewrite\n  \"Process the nodes of `hiccup` tree in a sequence of `stages`.\n\n  Stages are maps with the following keys (optional):\n    :transformers - sequence of transformer fns applied to each Hiccup node.\n    :wrapper      - fn applied to [node new-node] on successful transformations.\n    :default      - fn applied to every Hiccup node as a final step.\n\n  Note: a transformer is an fn that, given a Hiccup node, attempts to match the\n  node, returning a transformed node on matches, otherwise returning nil.\"\n  [hiccup stages]\n  (loop [[node :as loc] (hzip/hiccup-zip hiccup)]\n    (if (zip/end? loc)\n      (zip/root loc)\n      (recur (zip/next (if (vector? node)\n                         (let [new-node (reduce apply-stage node stages)]\n                           (if (not= node new-node)\n                             (zip/replace loc new-node)\n                             loc))\n                         loc))))))\n"]}
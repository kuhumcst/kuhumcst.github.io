{"version":3,"sources":["arrangement/core.cljc"],"mappings":";AAIA;;;;AAAA,AAAeA,AAGZC,AACAC,AACAC,AACAC,AACAC,AACAC,AACAC,AACAC,AACAC,AACAC,AACAC,AACAC;AAGH;;;;AAAA,AAAOC,AAGJC;AAHH,AAIE,AAAA,AAAOC;;AAAP,AACE,AAAI,AAAGA,AAAE,AAACC,AAAMhB;AACd,AAAMiB,AAAE,AAACC,AAAIlB,AAAgBe;AAA7B,AACE,AAAI,AAACE,AAAAA,AAAAA,AAAEH,AAAAA;AACLC;;AACA,AAAO,AAAA,AAAKA;;;;;AAChBA;;;;;AAGN;;;AAAA,AAAOI,AAEJF;AAFH,AAGE,AAAA,AAAA,AAAA,AAAA,AAAMA,AAAAA;;AAGR;;;;;AAAA,AAAOG,AAIJN;AAJH,AAMW,AAAMO,AAAE,AAACC,AAAKR;AACRS,AAAE,AAAQF;AADhB,AAEE,AAAI,AAACG,AAAOD;AACV,AAACE,AAAOJ;;AACRE;;;AAGf,AAAA,AAGA;;;;;AAAA,AAAOG,AAIJC,AAAGC;AAJN,AAKE,AAAOD,AAAGA;AACHC,AAAGA;;AADV,AAEE,AAAI,AAAK,AAACC,AAAIF,AAAI,AAACE,AAAID;AACrB,AAAMd,AAAE,AAACgB,AAAMH;AACTI,AAAE,AAACD,AAAMF;AACTI,AAAE,AAACC,AAAAA,AAAAA,AAAKnB,AAAAA,AAAEiB,AAAAA;AAFhB,AAGE,AAAI,AAAA,AAAOC;AACT,AAAO,AAACE,AAAKP;AAAI,AAACO,AAAKN;;;;;AACvBI;;;AACJ,AAAG,AAAChB,AAAMW,AAAI,AAACX,AAAMY;;;;;AAG3B;;;;;;;;;;;;;;;;AAAA,AAAMK,AAeHE,AAAEC;AAfL,AAgBE,AAAI,AAAYD,AAAEC;AAAlB;;AAEE,AAAMC,AAAM,AAACxB,AAAcsB;AACrBG,AAAM,AAACzB,AAAcuB;AAD3B,AAEE,AACE,AAAGC,AAAMC;AADX;;AAAA,AAEE,AAAGD,AAAMC;AAFX;;AAAA,AAIE,AAACnB,AAAqBkB;AACtB,AAACE,AAAQJ,AAAEC;;AALb,AAOE,AAACxB,AAAKuB;AACN,AAACT,AACC,AAACc,AAAQC,AAAIR,AAAK,AAACJ,AAAIM,AACvB,AAACK,AAAQC,AAAIR,AAAK,AAACJ,AAAIO;;AAV3B,AAYE,AAACzB,AAAKwB;AACN,AAAMO,AAAU,AAAG,AAAC1B,AAAMmB,AAAG,AAACnB,AAAMoB;AAApC,AACE,AAAI,AAAA,AAAOM;AACT,AAAChB,AAAaS,AAAEC;;AAChBM;;;AAhBN,AAkBE,AAACC,AAAMR;AACP,AAACT,AAAaS,AAAEC;;AAnBlB,AAsBE,AAAMQ,AAAW,AAACL,AAAQ,AAACnB,AAAUe,AAAG,AAACf,AAAUgB;AAAnD,AACE,AAAI,AAAA,AAAOQ;AAIA,AAACL,AAAQJ,AAAEC;;AACpBQ","names":["arrangement.core/type-predicates","cljs.core/nil?","cljs.core/false?","cljs.core/true?","cljs.core/number?","cljs.core/char?","cljs.core/string?","cljs.core/keyword?","cljs.core/symbol?","cljs.core/list?","cljs.core/vector?","cljs.core/set?","cljs.core/map?","arrangement.core/type-priority","x","i","cljs.core/count","p","cljs.core.nth","arrangement.core/directly-comparable?","arrangement.core/type-name","t","cljs.core/type","n","cljs.core/empty?","cljs.core.pr_str","arrangement.core/compare-seqs","xs","ys","cljs.core/seq","cljs.core/first","y","o","arrangement.core/rank","cljs.core/next","a","b","pri-a","pri-b","cljs.core/compare","cljs.core.sort_by","cljs.core/key","size-diff","cljs.core/coll?","class-diff"],"sourcesContent":["(ns arrangement.core\n  \"This namespace provides a total-ordering comparator for Clojure values.\")\n\n\n(def ^:private type-predicates\n  \"Ordered sequence of predicates to test to determine the relative ordering of\n  various data types.\"\n  [nil?\n   false?\n   true?\n   number?\n   char?\n   string?\n   keyword?\n   symbol?\n   list?\n   vector?\n   set?\n   map?])\n\n\n(defn- type-priority\n  \"Determines a numeric priority for the given value based on its general\n  type. See `type-predicates` for the ordering.\"\n  [x]\n  (loop [i 0]\n    (if (< i (count type-predicates))\n      (let [p (nth type-predicates i)]\n        (if (p x)\n          i\n          (recur (inc i))))\n      i)))\n\n\n(defn- directly-comparable?\n  \"True if the values in a certain priority class are directly comparable.\"\n  [p]\n  (<= 3 p 7))\n\n\n(defn- type-name\n  \"Get the type of the given object as a string. For Clojure, gets the name of\n  the class of the object. For ClojureScript, gets either the `name` attribute\n  or the protocol name if the `name` attribute doesn't exist.\"\n  [x]\n  #?(:clj (.getName (class x))\n     :cljs (let [t (type x)\n                 n (.-name t)]\n             (if (empty? n)\n               (pr-str t)\n               n))))\n\n\n(declare rank)\n\n\n(defn- compare-seqs\n  \"Compare sequences using the given comparator. If any element of the\n  sequences orders differently, it determines the ordering. Otherwise, if the\n  prefix matches, the longer sequence sorts later.\"\n  [xs ys]\n  (loop [xs xs\n         ys ys]\n    (if (and (seq xs) (seq ys))\n      (let [x (first xs)\n            y (first ys)\n            o (rank x y)]\n        (if (zero? o)\n          (recur (next xs) (next ys))\n          o))\n      (- (count xs) (count ys)))))\n\n\n(defn rank\n  \"Comparator function that provides a total ordering of EDN values. Values of\n  different types sort in order of their types, per `type-priority`. `false`\n  is before `true`, numbers are ordered by magnitude regardless of type, and\n  characters, strings, keywords, and symbols are ordered lexically.\n\n  Sequential collections are sorted by comparing their elements one at a time.\n  If the sequences have equal leading elements, the longer one is ordered later.\n  Sets are compared by cardinality first, then elements in sorted order.\n  Finally, maps are compared by their entries in sorted order of their keys.\n\n  All other types are sorted by class name. If the class implements\n  `Comparable`, the instances of it are compared using `compare`. Otherwise, the\n  values are ordered by print representation. This has the default behavior of\n  ordering by hash code if the type does not implement a custom print format.\"\n  [a b]\n  (if (identical? a b)\n    0\n    (let [pri-a (type-priority a)\n          pri-b (type-priority b)]\n      (cond\n        (< pri-a pri-b) -1\n        (> pri-a pri-b)  1\n\n        (directly-comparable? pri-a)\n        (compare a b)\n\n        (map? a)\n        (compare-seqs\n          (sort-by key rank (seq a))\n          (sort-by key rank (seq b)))\n\n        (set? a)\n        (let [size-diff (- (count a) (count b))]\n          (if (zero? size-diff)\n            (compare-seqs a b)\n            size-diff))\n\n        (coll? a)\n        (compare-seqs a b)\n\n        :else\n        (let [class-diff (compare (type-name a) (type-name b))]\n          (if (zero? class-diff)\n            #?(:clj (if (instance? java.lang.Comparable a)\n                      (compare a b)\n                      (compare (str a) (str b)))\n               :cljs (compare a b))\n            class-diff))))))\n"]}
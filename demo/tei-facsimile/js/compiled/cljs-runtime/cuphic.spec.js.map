{"version":3,"sources":["cuphic/spec.cljc"],"mappings":";AAIA,AAAA,AAAOA,AACJC;AADH,AAEE,AAAA,AAAAC,AAACC;AAAD,AAAO,AAAAD,AAACE,AAAmBH;AAAGI;;AAGhC,AAAAC,AAAA,AAAA,AAAA,AAAA,AACE,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAOC,AAAQ,AAAA,AAACR;AAElB,AAAAM,AAAA,AAAA,AAAA,AAAA,AACE,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAOC,AAAQ,AAAA,AAACR;AAElB,AAAAM,AAAA,AAAA,AAAA,AAAA,AACE,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAOC,AAAQ,AAAA,AAACR;AAGlB,AAAAM,AAAA,AAAA,AAAA,AAAA,AACE,AAAAG,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAKF,AAAAH,AAAA,AAAA,AAAA,AAAA,AACE,AAAAG,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAOF,AAAAH,AAAA,AAAA,AAAA,AAAA,AACE,AAAAG,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAIS,AAACC,AAAWC;AAEvB,AAAAL,AAAA,AAAA,AAAA,AAAA,AACE,AAAAM,AAAA,AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC,AAAUK,AAAS,AAAAV,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAAnB,AAAA,AAAAM,AAAAD;AAAA,AAAAC,AAAA,AAAA,AAAAC,AAAAC;AAAA,AAAA,AAAAC,AAAAD,AAAA;AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAKF,AAAAX,AAAA,AAAA,AAAA,AAAA,AACE,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAOa,AACA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAaC,AAAIA,AACjB,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAEQ,AAAAC,AAAA,AAAA,AAAA,AACG,AAAAC,AAAA,AAAA,AAAK,AAAAhB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAGS,AAACC,AAAWK;AAG9C,AAAAT,AAAA,AAAA,AAAA,AAAA,AACE,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAOa,AAAQ,AAAA,AAAA,AAACjB,AAAYuB;AAE9B","names":["cuphic.spec/prefixed-with?","s","p1__52013#","cljs.core.comp","clojure.string/starts-with?","cljs.core/name","cljs.spec.alpha/def-impl","cljs.spec.alpha/and-spec-impl","cljs.core/symbol?","cljs.spec.alpha/or-spec-impl","cljs.core/complement","cljs.core/coll?","cljs.spec.alpha.every_impl","cljs.spec.alpha.tuple_impl","G__52048","cljs.core/map?","i__13445__auto__","v__13446__auto__","cljs.core.nth","cljs.core/keyword?","cljs.core/vector?","cljs.spec.alpha.spec_impl","cljs.core/vec","cljs.spec.alpha/cat-impl","cljs.spec.alpha/maybe-impl","cljs.spec.alpha/rep-impl","cljs.core/first"],"sourcesContent":["(ns cuphic.spec\n  (:require [clojure.spec.alpha :as s]\n            [clojure.string :as str]))\n\n(defn- prefixed-with?\n  [s]\n  (comp #(str/starts-with? % s) name))                      ; CLJS needs name\n\n;; Every symbol prepended with ? has a single value captured in its place.\n(s/def ::?\n  (s/and symbol? (prefixed-with? \"?\")))\n\n(s/def ::*\n  (s/and symbol? (prefixed-with? \"*\")))\n\n(s/def ::+\n  (s/and symbol? (prefixed-with? \"+\")))\n\n;; Every symbol prepended with * or + is a placeholder for multiple items.\n(s/def ::quantifier\n  (s/or :* ::*\n        :+ ::+))\n\n;; If the prepended symbols are not given a specific name, their values are not\n;; captured, but rather ignored.\n(s/def ::ignored\n  (s/or\n    :? #{'?}\n    :* #{'*}\n    :+ #{'+}))\n\n;; Possible insertion points for single value placeholders and quantifiers.\n;; Cannot be used in place of collections, e.g. hiccup vectors or attr maps!\n(s/def ::slot\n  (s/or\n    :ignored ::ignored\n    :placeholder ::?\n    :quantifier ::quantifier\n    :value (complement coll?)))\n\n(s/def ::attr\n  (s/map-of keyword? (s/or\n                       :slot ::slot\n                       :map ::attr)))\n\n;; Conforms to a superset of regular hiccup.\n(s/def ::cuphic\n  (s/and vector?\n         (s/conformer vec vec)                              ; unform as vector\n         (s/cat\n           :tag ::slot\n           :attr (s/? ::attr)\n           :content (s/* (s/or\n                           :cuphic ::cuphic\n                           :slot ::slot\n                           :other (complement map?))))))\n\n;; TODO: reuse ::cuphic somehow?\n(s/def ::fragment\n  (s/and vector? (comp #{:<>} first)))\n\n(comment\n  ;; TODO: should be invalid according to spec\n  (s/conform ::cuphic '[*])\n  #_.)\n"]}
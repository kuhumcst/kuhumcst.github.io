{"version":3,"sources":["kuhumcst/recap/state.cljc"],"mappings":";AAMA,AAAAA,AAAA,AAAA,AAAA,AAAA,AACEC;AAIF,AAAAD,AAAA,AAAA,AAAA,AAAA,AACEE;AAEF,AAAAF,AAAA,AAAA,AAAA,AAAA,AACE,AAAAG,AAAA,AAAA,AAAA,AAASC,AAAKA;AAEhB,AAAAJ,AAAA,AAAA,AAAA,AAAA,AACE,AAAAK,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAEF,AAAAN,AAAA,AAAA,AAAA,AAAA,AACE,AAAAQ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAAA;AAAA,AAAA,AAAAE,AAAAF,AAAA;AAAA,AAAAA;AAAA,AAAA,AAAA,AAAAC,AAAAD,AAAA,AAAAE,AAAAF,AAAA;AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAGF,AAAAT,AAAA,AAAA,AAAA,AAAA,AACE,AAAAQ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAI;AAAA,AAAA,AAAAF,AAAAE;AAAA,AAAAA;AAAA,AAAA,AAAAD,AAAAC,AAAA;AAAA,AAAAA;AAAA,AAAA,AAAAD,AAAAC,AAAA;AAAA,AAAAA;AAAA,AAAA,AAAA,AAAAF,AAAAE,AAAA,AAAAD,AAAAC,AAAA,AAAA,AAAAD,AAAAC,AAAA;AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;AAEF;;;AAAA,AAAMC,AAEHC,AAAMC;AAFT,AAGE,AAAQ,AAAA,AAAAE,AAACC,AAASH,AAAMD;AAAxB;;AAAA,AAAA,AAAA,AAAAE,AAAA,AAAA,AAAA,AAAA,AAA+B,AAAA,AAAAC,AAACE,AAAcJ,AAAMD;;;AAEtD;;;AAAA,AAAMM,AAEHN;AAFH,AAGE,AAAI,AAACJ,AAAKI;AACR,AAACO,AAAOP;;AACRA;;;AAEJ;;;AAAA,AAAMQ,AAEHP,AAAKD;AAFR,AAGE,AAAAS,AAAM,AAACH,AAAUN;AAAjB,AAAA,AAAAS,AACGV,AAAaE;;AADhBQ","names":["cljs.spec.alpha/def-impl","cljs.core/int?","cljs.core/sequential?","cljs.spec.alpha.tuple_impl","cljs.core/any?","cljs.spec.alpha.every_impl","G__52382","cljs.core/coll?","cljs.spec.alpha/map-spec-impl","G__52385","cljs.core/map?","cljs.core/contains?","G__52394","kuhumcst.recap.state/assert-valid","state","spec","js/Error","cljs.core/deref","cljs.spec.alpha.valid_QMARK_","cljs.spec.alpha/explain-str","kuhumcst.recap.state/normalize","reagent.core.atom","kuhumcst.recap.state/prepare","G__52407"],"sourcesContent":["(ns kuhumcst.recap.state\n  \"Specs describing the shape of all state used in recap components.\"\n  (:require [clojure.spec.alpha :as s]\n            [reagent.core :as r]))\n\n;; TODO: or pos-int? will require reworking tabs drag/drop code slightly\n(s/def ::i\n  int?)\n\n;; Stricter interpretation more in line with the `coll` in `(nth coll n)` than\n;; the `coll?` predicate that annoyingly accepts maps and sets too.\n(s/def ::coll\n  sequential?)\n\n(s/def ::kv\n  (s/tuple any? any?))\n\n(s/def ::kvs\n  (s/coll-of ::kv))\n\n(s/def ::kvs+i\n  (s/keys :req-un [::kvs]\n          :opt-un [::i]))\n\n(s/def ::coll+i\n  (s/keys :req-un [::coll ::i]))\n\n(defn assert-valid\n  \"Assert that the current value of `state` conforms to the given `spec`.\"\n  [state spec]\n  (assert (s/valid? spec @state) (s/explain-str spec @state)))\n\n(defn normalize\n  \"Make sure that `state` provided as a plain map can also be dereferenced.\"\n  [state]\n  (if (map? state)\n    (r/atom state)\n    state))\n\n(defn prepare\n  \"Normalize and validate a piece of `state` according to `spec`.\"\n  [spec state]\n  (doto (normalize state)\n    (assert-valid spec)))\n"]}